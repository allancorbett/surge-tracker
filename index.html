<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#7a5ab3">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Contraction Tracker</title>
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/png" sizes="192x192" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      touch-action: manipulation;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f0f0f8;
      color: #333;
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 0 16px 32px;
    }

    h1 {
      font-size: 22px;
      font-weight: 700;
      color: #5a3d7a;
      margin: 24px 0 8px;
      text-align: center;
    }

    .btn-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 16px 0;
    }

    .track-btn {
      width: 160px;
      height: 160px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, #b8a8f7, #7a5ab3);
      color: #fff;
      font-size: 18px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(122, 90, 179, 0.35);
      -webkit-tap-highlight-color: transparent;
      transition: transform 0.1s;
      line-height: 1.3;
    }

    .track-btn:active {
      transform: scale(0.95);
    }

    .track-btn.active {
      background: linear-gradient(135deg, #f7a8a8, #b35a5a);
      box-shadow: 0 4px 20px rgba(179, 90, 90, 0.35);
      animation: pulse 1.2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes pop {
      0% { transform: scale(1); }
      50% { transform: scale(1.15); }
      100% { transform: scale(1); }
    }

    .pop {
      animation: pop 0.3s ease;
    }

    .timer {
      font-size: 32px;
      font-weight: 700;
      color: #b35a5a;
      margin-top: 12px;
      min-height: 40px;
      font-variant-numeric: tabular-nums;
    }

    .stats {
      display: flex;
      gap: 12px;
      justify-content: center;
      flex-wrap: wrap;
      margin: 8px 0 16px;
    }

    .stat-badge {
      background: #fff;
      border: 1px solid #e8e0f0;
      border-radius: 20px;
      padding: 6px 16px;
      font-size: 14px;
      color: #555;
    }

    .stat-badge strong {
      color: #5a3d7a;
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      max-width: 500px;
      margin-bottom: 16px;
    }

    .actions button {
      background: #fff;
      border: 1px solid #e8e0f0;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 13px;
      color: #555;
      cursor: pointer;
    }

    .actions button:hover {
      border-color: #7a5ab3;
      color: #7a5ab3;
    }

    .log-container {
      width: 100%;
      max-width: 500px;
      max-height: 400px;
      overflow-y: auto;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.06);
      margin-bottom: 16px;
    }

    .day-group {
      border-bottom: 1px solid #f0ecf5;
    }

    .day-group:last-child {
      border-bottom: none;
    }

    .day-header {
      position: sticky;
      top: 0;
      background: #f8f5fd;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 600;
      color: #7a5ab3;
      border-bottom: 1px solid #f0ecf5;
      z-index: 1;
    }

    .contraction-entry {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      border-bottom: 1px solid #f8f5fd;
      font-size: 14px;
      gap: 12px;
    }

    .contraction-entry:last-child {
      border-bottom: none;
    }

    .entry-time {
      font-weight: 600;
      color: #333;
      min-width: 65px;
    }

    .entry-duration {
      background: #f0ecf5;
      border-radius: 12px;
      padding: 2px 10px;
      font-size: 12px;
      color: #7a5ab3;
      font-weight: 600;
      white-space: nowrap;
    }

    .entry-interval {
      color: #999;
      font-size: 12px;
      margin-left: auto;
      white-space: nowrap;
    }

    .entry-delete {
      color: #ccc;
      cursor: pointer;
      font-size: 16px;
      padding: 0 4px;
      border: none;
      background: none;
    }

    .entry-delete:hover {
      color: #b35a5a;
    }

    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: #999;
      font-size: 14px;
    }

    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 20px;
    }

    .modal-overlay.open {
      display: flex;
    }

    .modal {
      background: #fff;
      border-radius: 16px;
      padding: 24px;
      width: 100%;
      max-width: 340px;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    }

    .modal h2 {
      font-size: 18px;
      color: #5a3d7a;
      margin-bottom: 16px;
    }

    .modal label {
      display: block;
      font-size: 13px;
      color: #555;
      margin-bottom: 4px;
    }

    .modal input {
      width: 100%;
      padding: 10px;
      border: 1px solid #e8e0f0;
      border-radius: 8px;
      font-size: 15px;
      margin-bottom: 12px;
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .modal-actions button {
      padding: 8px 18px;
      border-radius: 8px;
      border: 1px solid #e8e0f0;
      font-size: 14px;
      cursor: pointer;
      background: #fff;
      color: #555;
    }

    .modal-actions button.primary {
      background: #7a5ab3;
      color: #fff;
      border-color: #7a5ab3;
    }

    .chart-section {
      width: 100%;
      max-width: 500px;
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 1px 6px rgba(0, 0, 0, 0.06);
      padding: 16px;
      margin-bottom: 16px;
    }

    .chart-section h2 {
      font-size: 15px;
      color: #5a3d7a;
      margin-bottom: 12px;
    }

    .chart-section canvas {
      width: 100% !important;
      height: auto !important;
    }

    footer {
      text-align: center;
      font-size: 12px;
      color: #bbb;
      margin-top: auto;
      padding-top: 16px;
    }
  </style>
</head>
<body>
  <h1>Contraction Tracker</h1>

  <div class="btn-container">
    <button class="track-btn" id="trackBtn" onclick="toggleContraction()">
      Start<br>Contraction
    </button>
    <div class="timer" id="timer"></div>
  </div>

  <div class="stats" id="stats"></div>

  <div class="actions">
    <button onclick="showAddModal()">Add Past</button>
    <button onclick="exportCSV()">Export CSV</button>
    <button onclick="importCSV()">Import CSV</button>
    <button onclick="clearAll()">Clear All</button>
  </div>

  <div class="chart-section">
    <h2>Intervals Over Time</h2>
    <canvas id="chart"></canvas>
  </div>

  <div class="log-container" id="log"></div>

  <div class="modal-overlay" id="addModal" onclick="if(event.target===this)closeAddModal()">
    <div class="modal">
      <h2>Add Past Contraction</h2>
      <label for="addDate">Date</label>
      <input type="date" id="addDate">
      <label for="addTimeStart">Start Time</label>
      <input type="time" id="addTimeStart" step="1">
      <label for="addTimeEnd">End Time</label>
      <input type="time" id="addTimeEnd" step="1">
      <div class="modal-actions">
        <button onclick="closeAddModal()">Cancel</button>
        <button class="primary" onclick="addPast()">Add</button>
      </div>
    </div>
  </div>

  <input type="file" id="csvInput" accept=".csv" style="display:none" onchange="handleImport(event)">

  <footer>Contraction Tracker</footer>

  <script>
    const STORAGE_KEY = 'contractions';
    let activeStart = null;
    let timerInterval = null;

    // --- Data ---
    function getContractions() {
      try {
        return JSON.parse(localStorage.getItem(STORAGE_KEY)) || [];
      } catch {
        return [];
      }
    }

    function saveContractions(list) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(list));
    }

    // Each contraction: { start: ISO string, end: ISO string | null }

    // --- Timer ---
    function toggleContraction() {
      const btn = document.getElementById('trackBtn');
      if (activeStart) {
        // End contraction
        const now = new Date().toISOString();
        const list = getContractions();
        list.push({ start: activeStart, end: now });
        list.sort((a, b) => a.start.localeCompare(b.start));
        saveContractions(list);
        activeStart = null;
        clearInterval(timerInterval);
        timerInterval = null;
        btn.classList.remove('active');
        btn.innerHTML = 'Start<br>Contraction';
        document.getElementById('timer').textContent = '';
        btn.classList.add('pop');
        setTimeout(() => btn.classList.remove('pop'), 300);
        render();
      } else {
        // Start contraction
        activeStart = new Date().toISOString();
        btn.classList.add('active');
        btn.innerHTML = 'Stop<br>Contraction';
        updateTimer();
        timerInterval = setInterval(updateTimer, 100);
      }
    }

    function updateTimer() {
      if (!activeStart) return;
      const elapsed = Date.now() - new Date(activeStart).getTime();
      const secs = Math.floor(elapsed / 1000);
      const mins = Math.floor(secs / 60);
      const s = secs % 60;
      document.getElementById('timer').textContent =
        mins + ':' + String(s).padStart(2, '0');
    }

    // --- Formatting helpers ---
    function fmtTime(iso) {
      const d = new Date(iso);
      return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }

    function fmtDate(iso) {
      const d = new Date(iso);
      return d.toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' });
    }

    function fmtDuration(ms) {
      if (ms < 0) return '--';
      const totalSecs = Math.round(ms / 1000);
      const mins = Math.floor(totalSecs / 60);
      const secs = totalSecs % 60;
      if (mins === 0) return secs + 's';
      return mins + 'm ' + secs + 's';
    }

    function fmtInterval(ms) {
      if (ms < 0) return '';
      const totalSecs = Math.round(ms / 1000);
      const mins = Math.floor(totalSecs / 60);
      const secs = totalSecs % 60;
      if (mins < 60) return mins + 'm ' + secs + 's apart';
      const hrs = Math.floor(mins / 60);
      const m = mins % 60;
      return hrs + 'h ' + m + 'm apart';
    }

    // --- Render ---
    function render() {
      const list = getContractions();
      renderStats(list);
      renderLog(list);
      drawChart(list);
    }

    function renderStats(list) {
      const container = document.getElementById('stats');
      const today = new Date().toDateString();
      const todayCount = list.filter(c => new Date(c.start).toDateString() === today).length;

      // Average interval (last 10)
      let avgInterval = '--';
      if (list.length >= 2) {
        const recent = list.slice(-10);
        let totalMs = 0;
        let count = 0;
        for (let i = 1; i < recent.length; i++) {
          totalMs += new Date(recent[i].start).getTime() - new Date(recent[i - 1].start).getTime();
          count++;
        }
        if (count > 0) avgInterval = fmtDuration(totalMs / count);
      }

      // Average duration
      let avgDuration = '--';
      const withEnd = list.filter(c => c.end);
      if (withEnd.length > 0) {
        const totalDur = withEnd.reduce((s, c) =>
          s + (new Date(c.end).getTime() - new Date(c.start).getTime()), 0);
        avgDuration = fmtDuration(totalDur / withEnd.length);
      }

      container.innerHTML =
        '<span class="stat-badge">Today: <strong>' + todayCount + '</strong></span>' +
        '<span class="stat-badge">Total: <strong>' + list.length + '</strong></span>' +
        '<span class="stat-badge">Avg interval: <strong>' + avgInterval + '</strong></span>' +
        '<span class="stat-badge">Avg duration: <strong>' + avgDuration + '</strong></span>';
    }

    function renderLog(list) {
      const container = document.getElementById('log');
      if (list.length === 0) {
        container.innerHTML = '<div class="empty-state">No contractions recorded yet.<br>Tap the button to start tracking.</div>';
        return;
      }

      // Group by day, newest first
      const grouped = {};
      list.forEach((c, i) => {
        const day = new Date(c.start).toDateString();
        if (!grouped[day]) grouped[day] = [];
        grouped[day].push({ ...c, index: i });
      });

      const days = Object.keys(grouped).sort((a, b) => new Date(b) - new Date(a));
      let html = '';

      days.forEach(day => {
        const entries = grouped[day].sort((a, b) => b.start.localeCompare(a.start));
        html += '<div class="day-group">';
        html += '<div class="day-header">' + fmtDate(entries[0].start) + ' &mdash; ' + entries.length + ' contraction' + (entries.length !== 1 ? 's' : '') + '</div>';

        entries.forEach(entry => {
          const duration = entry.end
            ? fmtDuration(new Date(entry.end).getTime() - new Date(entry.start).getTime())
            : 'in progress';

          // Find interval to next contraction (previous in time)
          let interval = '';
          const allSorted = list.slice().sort((a, b) => a.start.localeCompare(b.start));
          const sortedIdx = allSorted.findIndex(c => c.start === entry.start);
          if (sortedIdx > 0) {
            const prev = allSorted[sortedIdx - 1];
            const ms = new Date(entry.start).getTime() - new Date(prev.start).getTime();
            interval = fmtInterval(ms);
          }

          html += '<div class="contraction-entry">';
          html += '<span class="entry-time">' + fmtTime(entry.start) + '</span>';
          html += '<span class="entry-duration">' + duration + '</span>';
          if (interval) html += '<span class="entry-interval">' + interval + '</span>';
          html += '<button class="entry-delete" onclick="deleteContraction(' + entry.index + ')">&times;</button>';
          html += '</div>';
        });

        html += '</div>';
      });

      container.innerHTML = html;
    }

    // --- Chart ---
    function drawChart(list) {
      const canvas = document.getElementById('chart');
      const ctx = canvas.getContext('2d');
      const dpr = window.devicePixelRatio || 1;
      const w = canvas.parentElement.clientWidth - 32;
      const h = 200;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      ctx.scale(dpr, dpr);

      ctx.clearRect(0, 0, w, h);

      if (list.length < 2) {
        ctx.fillStyle = '#ccc';
        ctx.font = '13px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Need at least 2 contractions to show chart', w / 2, h / 2);
        return;
      }

      const sorted = list.slice().sort((a, b) => a.start.localeCompare(b.start));

      // Calculate intervals (time between starts)
      const intervals = [];
      for (let i = 1; i < sorted.length; i++) {
        const ms = new Date(sorted[i].start).getTime() - new Date(sorted[i - 1].start).getTime();
        intervals.push({
          time: new Date(sorted[i].start).getTime(),
          ms: ms
        });
      }

      if (intervals.length === 0) return;

      const pad = { top: 20, right: 16, bottom: 30, left: 50 };
      const cw = w - pad.left - pad.right;
      const ch = h - pad.top - pad.bottom;

      const minTime = intervals[0].time;
      const maxTime = intervals[intervals.length - 1].time;
      const maxMs = Math.max(...intervals.map(i => i.ms));

      // Y axis: interval in minutes, 0 at bottom
      const maxMins = Math.ceil(maxMs / 60000);
      const yStep = maxMins <= 10 ? 2 : maxMins <= 30 ? 5 : maxMins <= 60 ? 10 : 30;

      // Grid and labels
      ctx.strokeStyle = '#f0ecf5';
      ctx.fillStyle = '#999';
      ctx.font = '11px -apple-system, sans-serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';

      for (let m = 0; m <= maxMins; m += yStep) {
        const y = pad.top + ch - (m / maxMins) * ch;
        ctx.beginPath();
        ctx.moveTo(pad.left, y);
        ctx.lineTo(w - pad.right, y);
        ctx.stroke();
        ctx.fillText(m + 'm', pad.left - 8, y);
      }

      // X axis labels
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      if (intervals.length > 1) {
        const timeRange = maxTime - minTime;
        const labelCount = Math.min(5, intervals.length);
        for (let i = 0; i < labelCount; i++) {
          const t = minTime + (timeRange * i) / (labelCount - 1);
          const x = pad.left + (cw * i) / (labelCount - 1);
          const d = new Date(t);
          const label = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          ctx.fillText(label, x, h - pad.bottom + 8);
        }
      }

      // Plot points
      intervals.forEach(pt => {
        const x = intervals.length === 1
          ? pad.left + cw / 2
          : pad.left + ((pt.time - minTime) / (maxTime - minTime)) * cw;
        const y = pad.top + ch - (pt.ms / 60000 / maxMins) * ch;

        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(122, 90, 179, 0.6)';
        ctx.fill();
        ctx.strokeStyle = '#7a5ab3';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      });

      // Connect with line
      if (intervals.length > 1) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(122, 90, 179, 0.3)';
        ctx.lineWidth = 1.5;
        intervals.forEach((pt, i) => {
          const x = pad.left + ((pt.time - minTime) / (maxTime - minTime)) * cw;
          const y = pad.top + ch - (pt.ms / 60000 / maxMins) * ch;
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }
    }

    // --- Actions ---
    function deleteContraction(index) {
      const list = getContractions();
      if (index >= 0 && index < list.length) {
        list.splice(index, 1);
        saveContractions(list);
        render();
      }
    }

    function showAddModal() {
      const now = new Date();
      document.getElementById('addDate').value = now.toISOString().slice(0, 10);
      document.getElementById('addTimeStart').value = '';
      document.getElementById('addTimeEnd').value = '';
      document.getElementById('addModal').classList.add('open');
    }

    function closeAddModal() {
      document.getElementById('addModal').classList.remove('open');
    }

    function addPast() {
      const date = document.getElementById('addDate').value;
      const startTime = document.getElementById('addTimeStart').value;
      const endTime = document.getElementById('addTimeEnd').value;
      if (!date || !startTime) return alert('Please enter date and start time.');

      const start = new Date(date + 'T' + startTime).toISOString();
      const end = endTime ? new Date(date + 'T' + endTime).toISOString() : null;

      const list = getContractions();
      list.push({ start, end });
      list.sort((a, b) => a.start.localeCompare(b.start));
      saveContractions(list);
      closeAddModal();
      render();
    }

    function exportCSV() {
      const list = getContractions();
      if (list.length === 0) return alert('No data to export.');
      let csv = 'start,end,duration_seconds,interval_seconds\n';
      const sorted = list.slice().sort((a, b) => a.start.localeCompare(b.start));
      sorted.forEach((c, i) => {
        const dur = c.end
          ? Math.round((new Date(c.end).getTime() - new Date(c.start).getTime()) / 1000)
          : '';
        let interval = '';
        if (i > 0) {
          interval = Math.round(
            (new Date(c.start).getTime() - new Date(sorted[i - 1].start).getTime()) / 1000
          );
        }
        csv += c.start + ',' + (c.end || '') + ',' + dur + ',' + interval + '\n';
      });
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'contractions-' + new Date().toISOString().slice(0, 10) + '.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    function importCSV() {
      document.getElementById('csvInput').click();
    }

    function handleImport(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function (e) {
        const lines = e.target.result.split('\n').filter(l => l.trim());
        if (lines.length < 2) return alert('CSV appears empty.');
        const header = lines[0].split(',');
        const startIdx = header.indexOf('start');
        const endIdx = header.indexOf('end');
        if (startIdx === -1) return alert('CSV must have a "start" column.');

        const list = getContractions();
        const existing = new Set(list.map(c => c.start));

        for (let i = 1; i < lines.length; i++) {
          const cols = lines[i].split(',');
          const start = cols[startIdx];
          if (!start || existing.has(start)) continue;
          const end = endIdx !== -1 && cols[endIdx] ? cols[endIdx] : null;
          list.push({ start, end });
          existing.add(start);
        }

        list.sort((a, b) => a.start.localeCompare(b.start));
        saveContractions(list);
        render();
        alert('Imported successfully.');
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function clearAll() {
      if (confirm('Delete all contraction data? This cannot be undone.')) {
        saveContractions([]);
        render();
      }
    }

    // --- Init ---
    window.addEventListener('resize', () => drawChart(getContractions()));
    render();

    // Register service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }
  </script>
</body>
</html>
